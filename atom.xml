<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Babyachievement</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://babyachievement.github.io/"/>
  <updated>2019-02-12T09:03:29.294Z</updated>
  <id>https://babyachievement.github.io/</id>
  
  <author>
    <name>babyachievement</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring-11-spring-cglib-repack</title>
    <link href="https://babyachievement.github.io/2019/02/12/Spring-11-spring-cglib-repack/"/>
    <id>https://babyachievement.github.io/2019/02/12/Spring-11-spring-cglib-repack/</id>
    <published>2019-02-12T07:56:36.000Z</published>
    <updated>2019-02-12T09:03:29.294Z</updated>
    
    <content type="html"><![CDATA[<p>在读Spring源码时看到了Spring代码中有一个Enhancer类，Spring使用CGLIB库了，为什么还要有Enhancer类？难道不会与CGLIB类冲突吗？带着以上两个疑问通读了一下S平日你改的Enhancer类，发现在setSuperclass中调用了setContextClass方法，在其周围发现了”SPRING PATCH”注释，该方法在Spring自定义的另一个类AbstractClassGenerator中添加，并且在其周围同样发现了”SPRING PATCH”注释。全局搜索了一下”SPRING PATCH”，发现在多个地方都有该注释：</p><img src="/2019/02/12/Spring-11-spring-cglib-repack/Spring_Patch.png" title="SPRING PATCH"><p>从字面上理解是Spring添加的patch，用来修复什么呢？先看一下AbstractClassGenerator中contextClass字段，该属性在generate方法中用到，用作ReflectUtils.defineClass的参数，看了一下defineClass方法的注释：“on JDK 9”，恍然大悟，原来是为了兼容JDK9，并且在其git commit中也有注释：“MethodHandles.Lookup.defineClass for CGLIB class definition purposes”。</p><p>ReflectUtils的defineClass方法定义如下；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public static Class defineClass(String className, byte[] b, ClassLoader loader,</span><br><span class="line">ProtectionDomain protectionDomain, Class&lt;?&gt; contextClass) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Class c = null;</span><br><span class="line">if (contextClass != null &amp;&amp; privateLookupInMethod != null &amp;&amp; lookupDefineClassMethod != null) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">MethodHandles.Lookup lookup = (MethodHandles.Lookup)</span><br><span class="line">privateLookupInMethod.invoke(null, contextClass, MethodHandles.lookup());</span><br><span class="line">c = (Class) lookupDefineClassMethod.invoke(lookup, b);</span><br><span class="line">&#125;</span><br><span class="line">catch (InvocationTargetException ex) &#123;</span><br><span class="line">Throwable target = ex.getTargetException();</span><br><span class="line">if (target.getClass() != LinkageError.class &amp;&amp; target.getClass() != IllegalArgumentException.class) &#123;</span><br><span class="line">throw new CodeGenerationException(target);</span><br><span class="line">&#125;</span><br><span class="line">// in case of plain LinkageError (class already defined)</span><br><span class="line">// or IllegalArgumentException (class in different package):</span><br><span class="line">// fall through to traditional ClassLoader.defineClass below</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new CodeGenerationException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (protectionDomain == null) &#123;</span><br><span class="line">protectionDomain = PROTECTION_DOMAIN;</span><br><span class="line">&#125;</span><br><span class="line">if (c == null) &#123;</span><br><span class="line">if (classLoaderDefineClassMethod != null) &#123;</span><br><span class="line">Object[] args = new Object[]&#123;className, b, 0, b.length, protectionDomain&#125;;</span><br><span class="line">try &#123;</span><br><span class="line">if (!classLoaderDefineClassMethod.isAccessible()) &#123;</span><br><span class="line">classLoaderDefineClassMethod.setAccessible(true);</span><br><span class="line">&#125;</span><br><span class="line">c = (Class) classLoaderDefineClassMethod.invoke(loader, args);</span><br><span class="line">&#125;</span><br><span class="line">catch (InvocationTargetException ex) &#123;</span><br><span class="line">throw new CodeGenerationException(ex.getTargetException());</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new CodeGenerationException(ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">throw new CodeGenerationException(THROWABLE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// Force static initializers to run.</span><br><span class="line">Class.forName(className, true, loader);</span><br><span class="line">return c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>MethodHandles.privateLookupIn和MethodHandles.Lookup.defineClass方法都是Java 9以后才有的，所以为了调用Lookup中的defineClass才在一些类中添加了patch代码。自然，自定义了一些类为了防止冲突，Spring在spring-core.gradle中定义了cglibRepackJar任务，改任务会将net.sf.cglib打包成spring-cglib-repack，打包spring-core jar时会根据添加了patch类，将spring-cglib-repack中相应的类排除掉。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">jar &#123;</span><br><span class="line">// Inline repackaged cglib classes directly into spring-core jar</span><br><span class="line">dependsOn cglibRepackJar</span><br><span class="line">from(zipTree(cglibRepackJar.archivePath)) &#123;</span><br><span class="line">include &quot;org/springframework/cglib/**&quot;</span><br><span class="line">exclude &quot;org/springframework/cglib/core/AbstractClassGenerator*.class&quot;</span><br><span class="line">exclude &quot;org/springframework/cglib/core/AsmApi*.class&quot;</span><br><span class="line">exclude &quot;org/springframework/cglib/core/KeyFactory.class&quot;</span><br><span class="line">exclude &quot;org/springframework/cglib/core/KeyFactory\$*.class&quot;</span><br><span class="line">exclude &quot;org/springframework/cglib/core/ReflectUtils*.class&quot;</span><br><span class="line">exclude &quot;org/springframework/cglib/proxy/Enhancer*.class&quot;</span><br><span class="line">exclude &quot;org/springframework/cglib/proxy/MethodProxy*.class&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dependsOn objenesisRepackJar</span><br><span class="line">from(zipTree(objenesisRepackJar.archivePath)) &#123;</span><br><span class="line">include &quot;org/springframework/objenesis/**&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在读Spring源码时看到了Spring代码中有一个Enhancer类，Spring使用CGLIB库了，为什么还要有Enhancer类？难道不会与CGLIB类冲突吗？带着以上两个疑问通读了一下S平日你改的Enhancer类，发现在setSuperclass中调用了setCo
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
      <category term="AOP" scheme="https://babyachievement.github.io/tags/AOP/"/>
    
      <category term="CGLIB" scheme="https://babyachievement.github.io/tags/CGLIB/"/>
    
  </entry>
  
  <entry>
    <title>Spring-10-AOP-cglib</title>
    <link href="https://babyachievement.github.io/2019/02/12/Spring-10-AOP-cglib/"/>
    <id>https://babyachievement.github.io/2019/02/12/Spring-10-AOP-cglib/</id>
    <published>2019-02-12T02:28:32.000Z</published>
    <updated>2019-02-12T07:57:08.670Z</updated>
    
    <content type="html"><![CDATA[<p>　　　　在AopProxy接口实现中，有使用CGLIB来生成代理对象的实现，这个Proxy代理对象的生成可以在CglibAopProxy代码中看到。在这个代理对象的生成过程中，需要注意的是对Enhancer对象callback回调的设置。在Enhancer的callback回调设置中，实际是通过设置DynamicAdvisedInterceptor拦截器来实现AOP功能的，可以在getCallbacks中看到DynamicAdvisedInterceptor的设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">(@Nullable ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating CGLIB proxy: "</span> + <span class="keyword">this</span>.advised.getTargetSource());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class&lt;?&gt; rootClass = <span class="keyword">this</span>.advised.getTargetClass();</span><br><span class="line">Assert.state(rootClass != <span class="keyword">null</span>, <span class="string">"Target class must be available for creating a CGLIB proxy"</span>);</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; proxySuperClass = rootClass;</span><br><span class="line"><span class="keyword">if</span> (ClassUtils.isCglibProxyClass(rootClass)) &#123;</span><br><span class="line">proxySuperClass = rootClass.getSuperclass();</span><br><span class="line">Class&lt;?&gt;[] additionalInterfaces = rootClass.getInterfaces();</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; additionalInterface : additionalInterfaces) &#123;</span><br><span class="line"><span class="keyword">this</span>.advised.addInterface(additionalInterface);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Validate the class, writing log messages as necessary.</span></span><br><span class="line">validateClassIfNecessary(proxySuperClass, classLoader);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure CGLIB Enhancer...</span></span><br><span class="line">Enhancer enhancer = createEnhancer();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">enhancer.setClassLoader(classLoader);</span><br><span class="line"><span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> SmartClassLoader &amp;&amp;</span><br><span class="line">((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &#123;</span><br><span class="line">enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">enhancer.setSuperclass(proxySuperClass);</span><br><span class="line">enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(<span class="keyword">this</span>.advised));</span><br><span class="line">enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);</span><br><span class="line">enhancer.setStrategy(<span class="keyword">new</span> ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));</span><br><span class="line"></span><br><span class="line">Callback[] callbacks = getCallbacks(rootClass);</span><br><span class="line">Class&lt;?&gt;[] types = <span class="keyword">new</span> Class&lt;?&gt;[callbacks.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; types.length; x++) &#123;</span><br><span class="line">types[x] = callbacks[x].getClass();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fixedInterceptorMap only populated at this point, after getCallbacks call above</span></span><br><span class="line">enhancer.setCallbackFilter(<span class="keyword">new</span> ProxyCallbackFilter(</span><br><span class="line"><span class="keyword">this</span>.advised.getConfigurationOnlyCopy(), <span class="keyword">this</span>.fixedInterceptorMap, <span class="keyword">this</span>.fixedInterceptorOffset));</span><br><span class="line">enhancer.setCallbackTypes(types);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate the proxy class and create a proxy instance.</span></span><br><span class="line"><span class="keyword">return</span> createProxyClassAndInstance(enhancer, callbacks);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (CodeGenerationException | IllegalArgumentException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Could not generate CGLIB subclass of "</span> + <span class="keyword">this</span>.advised.getTargetClass() +</span><br><span class="line"><span class="string">": Common causes of this problem include using a final class or a non-visible class"</span>,</span><br><span class="line">ex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="comment">// TargetSource.getTarget() failed</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"Unexpected AOP exception"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  cglib是一个java 字节码的生成工具，它是对asm的进一步封装。</p><a id="more"></a>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　　　在AopProxy接口实现中，有使用CGLIB来生成代理对象的实现，这个Proxy代理对象的生成可以在CglibAopProxy代码中看到。在这个代理对象的生成过程中，需要注意的是对Enhancer对象callback回调的设置。在Enhancer的callback回调设置中，实际是通过设置DynamicAdvisedInterceptor拦截器来实现AOP功能的，可以在getCallbacks中看到DynamicAdvisedInterceptor的设置。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;33&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;34&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;35&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;36&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;37&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;38&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;39&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;40&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;41&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;42&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;43&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;44&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;45&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;46&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;47&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;48&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;49&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;50&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;51&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;52&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;53&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;54&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;55&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;56&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;57&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;58&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; Object &lt;span class=&quot;title&quot;&gt;getProxy&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(@Nullable ClassLoader classLoader)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (logger.isTraceEnabled()) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		logger.trace(&lt;span class=&quot;string&quot;&gt;&quot;Creating CGLIB proxy: &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.advised.getTargetSource());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;try&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Class&amp;lt;?&amp;gt; rootClass = &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.advised.getTargetClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Assert.state(rootClass != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Target class must be available for creating a CGLIB proxy&quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Class&amp;lt;?&amp;gt; proxySuperClass = rootClass;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (ClassUtils.isCglibProxyClass(rootClass)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			proxySuperClass = rootClass.getSuperclass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			Class&amp;lt;?&amp;gt;[] additionalInterfaces = rootClass.getInterfaces();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Class&amp;lt;?&amp;gt; additionalInterface : additionalInterfaces) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.advised.addInterface(additionalInterface);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Validate the class, writing log messages as necessary.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		validateClassIfNecessary(proxySuperClass, classLoader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Configure CGLIB Enhancer...&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Enhancer enhancer = createEnhancer();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (classLoader != &lt;span class=&quot;keyword&quot;&gt;null&lt;/span&gt;) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			enhancer.setClassLoader(classLoader);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; (classLoader &lt;span class=&quot;keyword&quot;&gt;instanceof&lt;/span&gt; SmartClassLoader &amp;amp;&amp;amp;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;					((SmartClassLoader) classLoader).isClassReloadable(proxySuperClass)) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				enhancer.setUseCache(&lt;span class=&quot;keyword&quot;&gt;false&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		enhancer.setSuperclass(proxySuperClass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.advised));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		enhancer.setStrategy(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Callback[] callbacks = getCallbacks(rootClass);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		Class&amp;lt;?&amp;gt;[] types = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Class&amp;lt;?&amp;gt;[callbacks.length];&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; x = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;; x &amp;lt; types.length; x++) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;			types[x] = callbacks[x].getClass();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// fixedInterceptorMap only populated at this point, after getCallbacks call above&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		enhancer.setCallbackFilter(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; ProxyCallbackFilter(&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.advised.getConfigurationOnlyCopy(), &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.fixedInterceptorMap, &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.fixedInterceptorOffset));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		enhancer.setCallbackTypes(types);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// Generate the proxy class and create a proxy instance.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; createProxyClassAndInstance(enhancer, callbacks);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (CodeGenerationException | IllegalArgumentException ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AopConfigException(&lt;span class=&quot;string&quot;&gt;&quot;Could not generate CGLIB subclass of &quot;&lt;/span&gt; + &lt;span class=&quot;keyword&quot;&gt;this&lt;/span&gt;.advised.getTargetClass() +&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				&lt;span class=&quot;string&quot;&gt;&quot;: Common causes of this problem include using a final class or a non-visible class&quot;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;				ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;catch&lt;/span&gt; (Throwable ex) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;comment&quot;&gt;// TargetSource.getTarget() failed&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;		&lt;span class=&quot;keyword&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; AopConfigException(&lt;span class=&quot;string&quot;&gt;&quot;Unexpected AOP exception&quot;&lt;/span&gt;, ex);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;  cglib是一个java 字节码的生成工具，它是对asm的进一步封装。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
      <category term="AOP" scheme="https://babyachievement.github.io/tags/AOP/"/>
    
      <category term="CGLIB" scheme="https://babyachievement.github.io/tags/CGLIB/"/>
    
  </entry>
  
  <entry>
    <title>Go-标准库</title>
    <link href="https://babyachievement.github.io/2019/01/23/Go-%E6%A0%87%E5%87%86%E5%BA%93/"/>
    <id>https://babyachievement.github.io/2019/01/23/Go-标准库/</id>
    <published>2019-01-23T08:03:32.000Z</published>
    <updated>2019-01-23T08:13:45.388Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th></th><th style="text-align:center"></th><th></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:center"></th><th style="text-align:right"></th></tr></thead><tbody><tr><td>archive</td><td style="text-align:center">bufio</td><td>bytes</td><td style="text-align:center">compress</td><td style="text-align:center">container</td><td style="text-align:center">crypto</td><td style="text-align:right">database</td></tr><tr><td>debug</td><td style="text-align:center">encoding</td><td>errors</td><td style="text-align:center">expvar</td><td style="text-align:center">flag</td><td style="text-align:center">fmt</td><td style="text-align:right">go</td></tr><tr><td>hash</td><td style="text-align:center">html</td><td>image</td><td style="text-align:center">index</td><td style="text-align:center">io</td><td style="text-align:center">log</td><td style="text-align:right">match</td></tr><tr><td>mime</td><td style="text-align:center">net</td><td>os</td><td style="text-align:center">path</td><td style="text-align:center">reflect</td><td style="text-align:center">regexp</td><td style="text-align:right">runtime</td></tr><tr><td>sort</td><td style="text-align:center">strconv</td><td>strings</td><td style="text-align:center">sync</td><td style="text-align:center">syscall</td><td style="text-align:center">testing</td><td style="text-align:right">text</td></tr><tr><td>time</td><td style="text-align:center">unicode</td><td>unsafe</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:cente
      
    
    </summary>
    
    
      <category term="Go" scheme="https://babyachievement.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Go-并发</title>
    <link href="https://babyachievement.github.io/2019/01/22/Go-%E5%B9%B6%E5%8F%91/"/>
    <id>https://babyachievement.github.io/2019/01/22/Go-并发/</id>
    <published>2019-01-22T06:55:04.000Z</published>
    <updated>2019-01-22T06:55:04.536Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Go-引用类型</title>
    <link href="https://babyachievement.github.io/2019/01/21/Go-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://babyachievement.github.io/2019/01/21/Go-引用类型/</id>
    <published>2019-01-21T09:54:51.000Z</published>
    <updated>2019-01-21T10:06:46.234Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称为标头（header）值。从技术细节上说，字符串也是一种引用类型。每个应用类型创建的标头值是包含一个执行底层数据结构的指针。每个引用类型还包含一组独特的字段，用于管理底层数据结构。因为标头值是为复制而设计的，所以用与按不需要共享一个引用类型的值。标头值里包含一个指针，因此通过复制来传递一个应用类型的值的副本，本质上就是在共享底层的数据结构。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> IP []<span class="keyword">type</span></span><br></pre></td></tr></table></figure><p>上述代码展示了一个名为IP的类型，这个类型被声明为字节切片。当腰围绕相关的内置类型或者应用类型来声明用户自定义的行为时，直接基于已有类型来声明用户定义的类型会很好用。编译器只允许为命名的用户定义的类型声明方法，如下代码所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ip IP)</span> <span class="title">MarshalText</span><span class="params">()</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ip) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> []byre(<span class="string">""</span>), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ip) != IPv4len &amp;&amp; <span class="built_in">len</span>(ip) != IPv6len &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"invalid IP address"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> []<span class="keyword">byte</span>(ip.String()), <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码里定义的MarshalText方法是用IP类型的值接收者声明的。一个值接受者，正像预期的那样通过复制来传递引用，从而不需要通过指针来共享应用类型的值。这种传递方法也可以应用到函数或者方法的参数传递中，以及返回值中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ipEmtpyString</span><span class="params">(ip IP)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(ip) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip.String()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Go语言里的引用类型有如下几个：切片、映射、通道、接口和函数类型。当声明上述类型的变量时，创建的变量被称为标头（header）值。从技术细节上说，字符串也是一种引用类型。每个应用类型创建的标头值是包含一个执行底层数据结构的指针。每个引用类型还包含一组独特的字段，用于管理底层
      
    
    </summary>
    
    
      <category term="Go" scheme="https://babyachievement.github.io/tags/Go/"/>
    
  </entry>
  
  <entry>
    <title>Spring-9-AOP执行过程</title>
    <link href="https://babyachievement.github.io/2019/01/10/Spring-9-AOP%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/"/>
    <id>https://babyachievement.github.io/2019/01/10/Spring-9-AOP执行过程/</id>
    <published>2019-01-10T10:18:04.000Z</published>
    <updated>2019-01-10T10:18:21.993Z</updated>
    
    <content type="html"><![CDATA[<p>DefaultAdvisorAdapterRegistry<br>  MethodBeforeAdviceAdapter<br>  AfterReturningAdviceAdapter<br>  ThrowsAdviceAdapter</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;DefaultAdvisorAdapterRegistry&lt;br&gt;  MethodBeforeAdviceAdapter&lt;br&gt;  AfterReturningAdviceAdapter&lt;br&gt;  ThrowsAdviceAdapter&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-8-AOP设计与实现</title>
    <link href="https://babyachievement.github.io/2019/01/10/Spring-8-AOP%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/"/>
    <id>https://babyachievement.github.io/2019/01/10/Spring-8-AOP设计与实现/</id>
    <published>2019-01-10T03:53:35.000Z</published>
    <updated>2019-02-12T10:03:29.661Z</updated>
    
    <content type="html"><![CDATA[<p>　　　　Spring AOP核心技术是代理，为了让Spring AOP起作用，Spring内部需要完成一系列过程，如使用JDK动态代理或者CGLIB创建代理对象，然后启动代理对象拦截器完成横切面的织入。</p><a id="more"></a><h2 id="代理对象的创建"><a href="#代理对象的创建" class="headerlink" title="代理对象的创建"></a>代理对象的创建</h2><p>　　　　Spring中通过配置和调用ProxyFactoryBean来生成代理对象，在生成过程中可以使用JDK的Proxy和CGLIB两种生成方式。</p><img src="/2019/01/10/Spring-8-AOP设计与实现/ProxyFactoryBean.png" title="ProxyFactoryBean类图"><p>　　　　由上图可以看出，完成AOP应用的类有AspectJProxyFactory、ProxyFactory和ProxyFactoryBean，它们都是ProxyConfig、AdvisedSupport和ProxyCreatorSupport的子类。ProxyConfig为子类提供类配置属性；AdvisedSupport封装了对通着和通知器的相关操作，这些操作对于不同AOP代理对象的生成都是一样的，但对于具体的AOP代理对象的创建，AdvisedSupport则将其委托给它的子类去完成；ProxyCreatorSupport可以看做子类创建AOP代理对象的辅助类。具体AOP代理对象的生成，根据需要分别由ProxyFactoryBea、AspectJProxyFactory和ProxyFactory完成。对于使用AspectJ的AOP应用，AspectJProxyFactory起到集成Spring和AspectJ的作用；对于使用Spring AOP的应用，ProxyFactoryBean和ProxyFactory都提供了AOP功能的封装，只是使用ProxyFactoryBean可以做IoC容器中完成声明式配置，而使用ProxyFactory，则需要编程式地使用Spring AOP功能。</p><h3 id="ProxyFactory"><a href="#ProxyFactory" class="headerlink" title="ProxyFactory"></a>ProxyFactory</h3><img src="/2019/01/10/Spring-8-AOP设计与实现/ProxyFactory.png" title="ProxyFactory调用栈"><p>　　　　AspectJAwareAdvisorAutoProxyCreator实现了BeanPostProcessor接口，在Bean被创建后AspectJAwareAdvisorAutoProxyCreator的postProcessAfterInitialization会被调用，postProcessAfterInitialization是在AspectJAwareAdvisorAutoProxyCreator的父类AbstractAutoProxyCreator中定义的，该方法会调用wrapIfNecessary查找满足条件的Advisor，然后为其常见代理对象。代理对象的创建会委托给AopProxyFactory，Spring提供了默认的AOPProxyFactory：DefaultAopProxyFactory，DefaultAopProxyFactory根据判断结果为其创建Java Proxy或Cglib Proxy。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AopProxy <span class="title">createAopProxy</span><span class="params">(AdvisedSupport config)</span> <span class="keyword">throws</span> AopConfigException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;</span><br><span class="line">Class&lt;?&gt; targetClass = config.getTargetClass();</span><br><span class="line"><span class="keyword">if</span> (targetClass == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AopConfigException(<span class="string">"TargetSource cannot determine target class: "</span> +</span><br><span class="line"><span class="string">"Either an interface or a target is required for proxy creation."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ObjenesisCglibAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> JdkDynamicAopProxy(config);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　　　由上面的代码可以看到，Spring并没有直接创建一个CglibAopProxy，而是创建了一个ObjenesisCglibAopProxy，通过使用Objenesis，不需要代理类有默认构造函数，并且如果使用Objenesis创建代理对象失败，其会自动fall back使用Cglib创建代理对象，具体参考Spring git commit:1f9e8f68d445ae1d16e27ccde97403efaaa23a81</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected Object createProxyClassAndInstance(Enhancer enhancer, Callback[] callbacks) &#123;</span><br><span class="line">Class&lt;?&gt; proxyClass = enhancer.createClass();</span><br><span class="line">Object proxyInstance = null;</span><br><span class="line"></span><br><span class="line">if (objenesis.isWorthTrying()) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">proxyInstance = objenesis.newInstance(proxyClass, enhancer.getUseCache());</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">logger.debug(&quot;Unable to instantiate proxy using Objenesis, &quot; +</span><br><span class="line">&quot;falling back to regular proxy construction&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (proxyInstance == null) &#123;</span><br><span class="line">// Regular instantiation via default constructor...</span><br><span class="line">try &#123;</span><br><span class="line">Constructor&lt;?&gt; ctor = (this.constructorArgs != null ?</span><br><span class="line">proxyClass.getDeclaredConstructor(this.constructorArgTypes) :</span><br><span class="line">proxyClass.getDeclaredConstructor());</span><br><span class="line">ReflectionUtils.makeAccessible(ctor);</span><br><span class="line">proxyInstance = (this.constructorArgs != null ?</span><br><span class="line">ctor.newInstance(this.constructorArgs) : ctor.newInstance());</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new AopConfigException(&quot;Unable to instantiate proxy using Objenesis, &quot; +</span><br><span class="line">&quot;and regular proxy instantiation via default constructor fails as well&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">((Factory) proxyInstance).setCallbacks(callbacks);</span><br><span class="line">return proxyInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://jira.spring.io/browse/SPR-10594?redirect=false" target="_blank" rel="noopener">Add ability to create proxy around classes that has no default constructor</a><br><a href="https://blog.codeleak.pl/2014/07/spring-4-cglib-based-proxy-classes-with-no-default-ctor.html" target="_blank" rel="noopener">SPRING 4: CGLIB-BASED PROXY CLASSES WITH NO DEFAULT CONSTRUCTOR</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　　　Spring AOP核心技术是代理，为了让Spring AOP起作用，Spring内部需要完成一系列过程，如使用JDK动态代理或者CGLIB创建代理对象，然后启动代理对象拦截器完成横切面的织入。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
      <category term="AOP" scheme="https://babyachievement.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring-7-AOP基础</title>
    <link href="https://babyachievement.github.io/2019/01/10/Spring-7-AOP%E5%9F%BA%E7%A1%80/"/>
    <id>https://babyachievement.github.io/2019/01/10/Spring-7-AOP基础/</id>
    <published>2019-01-10T02:20:23.000Z</published>
    <updated>2019-01-10T06:11:05.082Z</updated>
    
    <content type="html"><![CDATA[<p>　　　　AOP联盟将AOP体系从高到低分成三个层次，最高层是语言和开发环境，在这个层次中有几个重要的概念：“基础”（base）为增强对象或者说目标对象；“切面”（aspect）通常包含低于基础的增强应用；“配置”（configuration）可以视为编织，将基础和切面编织组合起来以达到对目标对象的编织。</p><p>　　　　编织逻辑的具体实现方法有反射、程序预处理、拦截器框架、类装载器框架、元数据处理等。Spring AOP中使用的是Java语言特性如Java Proxy、拦截器等技术。</p><a id="more"></a><h2 id="Advice（通知）"><a href="#Advice（通知）" class="headerlink" title="Advice（通知）"></a>Advice（通知）</h2><p>Advice定义了在连接点做什么，为切面增强提供织入入口。在Spring AOP中，主要描述Spring AOP围绕方法调用而注入的切面行为。Advice由AOP联盟定义，在org.aopalliance包中。Spring AOP使用了这个接口，并做了扩展，提供了更细化的通知类型，如BeforeAdvice、AfterAdvice、ThrowAdvice等。</p><ol><li>BeforeAdvice: 目标被被使用前调用，目前只有目标方法被调用前的通知MethodBeforeAdvice，未来可能会有Field Advice；</li><li>AfterAdvice：后置通知表记接口，子接口有AfterReturningAdvice和ThrowsAdvice；</li><li>ThrowAdvice：异常处理表记接口，AfterAdvice的子接口，此接口并没有提供方法，是通过反射调用，所以此接口的实现必须有以下四个方法中的一个，具体看一参考ThrowsAdviceInterceptor类：<ul><li>public void afterThrowing(Exception ex)</li><li>public void afterThrowing(RemoteException)</li><li>public void afterThrowing(Method method, Object[] args, Object target, Exception ex)</li><li>public void afterThrowing(Method method, Object[] args, Object target, ServletException ex)</li></ul></li></ol><h2 id="PointCut（切点）"><a href="#PointCut（切点）" class="headerlink" title="PointCut（切点）"></a>PointCut（切点）</h2><p>PointCut用来表示Advice将要作用的连接点，通过PointCut来定义需要增强的方法集合。Spring提供了一些开箱即用的PointCut类，类图如下：</p><img src="/2019/01/10/Spring-7-AOP基础/Pointcut.png" title="Pointcut类图"><p>PointCut接口提供了两个方法分别返回ClassFilter和MethodMatcher，用于过滤类和匹配方法。</p><h2 id="Advisor-通知器"><a href="#Advisor-通知器" class="headerlink" title="Advisor(通知器)"></a>Advisor(通知器)</h2><p>Advisor将Advice和PointCut组合起来，定义了在哪个PointCut应用哪个Advice。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;　　　　AOP联盟将AOP体系从高到低分成三个层次，最高层是语言和开发环境，在这个层次中有几个重要的概念：“基础”（base）为增强对象或者说目标对象；“切面”（aspect）通常包含低于基础的增强应用；“配置”（configuration）可以视为编织，将基础和切面编织组合起来以达到对目标对象的编织。&lt;/p&gt;
&lt;p&gt;　　　　编织逻辑的具体实现方法有反射、程序预处理、拦截器框架、类装载器框架、元数据处理等。Spring AOP中使用的是Java语言特性如Java Proxy、拦截器等技术。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
      <category term="AOP" scheme="https://babyachievement.github.io/tags/AOP/"/>
    
  </entry>
  
  <entry>
    <title>Spring-4-Bean创建</title>
    <link href="https://babyachievement.github.io/2019/01/03/Spring-4-Bean%E5%88%9B%E5%BB%BA/"/>
    <id>https://babyachievement.github.io/2019/01/03/Spring-4-Bean创建/</id>
    <published>2019-01-03T01:55:04.000Z</published>
    <updated>2019-01-09T08:31:06.639Z</updated>
    
    <content type="html"><![CDATA[<p>Bean实例化创建是在AbstractApplicationContext的refresh方法中开始的，具体调用时finishBeanFactoryInitialization方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册并实例化BeanPostProcessor</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 其余Bean实例化(non-lazy-init) singletons.</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Last step: publish corresponding event.</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finishBeanFactoryInitialization</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 设置ConversionService用于类型转换</span></span><br><span class="line"><span class="keyword">if</span> (beanFactory.containsBean(CONVERSION_SERVICE_BEAN_NAME) &amp;&amp;</span><br><span class="line">beanFactory.isTypeMatch(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class)) &#123;</span><br><span class="line">beanFactory.setConversionService(</span><br><span class="line">beanFactory.getBean(CONVERSION_SERVICE_BEAN_NAME, ConversionService.class));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果没有Register a default embedded value resolver if no bean post-processor</span></span><br><span class="line"><span class="comment">// (such as a PropertyPlaceholderConfigurer bean) registered any before:</span></span><br><span class="line"><span class="comment">// at this point, primarily for resolution in annotation attribute values.</span></span><br><span class="line"><span class="keyword">if</span> (!beanFactory.hasEmbeddedValueResolver()) &#123;</span><br><span class="line">beanFactory.addEmbeddedValueResolver(strVal -&gt; getEnvironment().resolvePlaceholders(strVal));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Initialize LoadTimeWeaverAware beans early to allow for registering their transformers early.</span></span><br><span class="line">String[] weaverAwareNames = beanFactory.getBeanNamesForType(LoadTimeWeaverAware.class, <span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">for</span> (String weaverAwareName : weaverAwareNames) &#123;</span><br><span class="line">getBean(weaverAwareName);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop using the temporary ClassLoader for type matching.</span></span><br><span class="line">beanFactory.setTempClassLoader(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许缓存所有的bean definition，不允许再修改Bean definition</span></span><br><span class="line">beanFactory.freezeConfiguration();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></span><br><span class="line"><span class="comment">// 这里开始真正的实例化单例Bean</span></span><br><span class="line">beanFactory.preInstantiateSingletons();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DefaultListableBeanFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></span><br><span class="line"><span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></span><br><span class="line">List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.beanDefinitionNames);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</span><br><span class="line"><span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</span><br><span class="line"><span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</span><br><span class="line">Object bean = getBean(FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line"><span class="keyword">if</span> (bean <span class="keyword">instanceof</span> FactoryBean) &#123;</span><br><span class="line"><span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) bean;</span><br><span class="line"><span class="keyword">boolean</span> isEagerInit;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</span><br><span class="line">isEagerInit = AccessController.doPrivileged((PrivilegedAction&lt;Boolean&gt;)</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory)::isEagerInit,</span><br><span class="line">getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</span><br><span class="line">((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isEagerInit) &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">getBean(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Trigger post-initialization callback for all applicable beans...</span></span><br><span class="line"><span class="keyword">for</span> (String beanName : beanNames) &#123;</span><br><span class="line">Object singletonInstance = getSingleton(beanName);</span><br><span class="line"><span class="keyword">if</span> (singletonInstance <span class="keyword">instanceof</span> SmartInitializingSingleton) &#123;</span><br><span class="line"><span class="keyword">final</span> SmartInitializingSingleton smartSingleton = (SmartInitializingSingleton) singletonInstance;</span><br><span class="line"><span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">AccessController.doPrivileged((PrivilegedAction&lt;Object&gt;) () -&gt; &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;, getAccessControlContext());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">smartSingleton.afterSingletonsInstantiated();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Bean实例化创建是在AbstractApplicationContext的refresh方法中开始的，具体调用时finishBeanFactoryInitialization方法。&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-3.1-Loading BeanDefinitions</title>
    <link href="https://babyachievement.github.io/2018/12/28/Spring-3-1-Loading-BeanDefinitions/"/>
    <id>https://babyachievement.github.io/2018/12/28/Spring-3-1-Loading-BeanDefinitions/</id>
    <published>2018-12-28T09:56:11.000Z</published>
    <updated>2019-01-02T10:52:53.889Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeanDefinition的自动加载"><a href="#BeanDefinition的自动加载" class="headerlink" title="BeanDefinition的自动加载"></a>BeanDefinition的自动加载</h2><p>　　　　一种是从XML中解析，二是注解自动扫描，三是显式创建并注册到BeanDefinitionRegistry中。</p><h3 id="XML-中BeanDefinition加载"><a href="#XML-中BeanDefinition加载" class="headerlink" title="XML 中BeanDefinition加载"></a>XML 中BeanDefinition加载</h3><p>　　　　BeanDefinition的加载，由《Spring-2-ApplicationContext》中知道obtainFreshBeanFactory会调用refreshBeanFactory和getBeanFactory方法，refreshBeanFactory方法由子类实现，实现了该方法的子类有两个：AbstractRefreshableApplicationContext和GenericApplicationContext，GenericApplicationContext的实现只是设置了序列化ID，并不提供自动扫描，这里只介绍AbstractRefreshableApplicationContext的实现。AbstractRefreshableApplicationContext的实现中调用了loadBeanDefinitions方法，该loadBeanDefinitions方法为抽象方法，将执行真正的BeanDefinition加载，具体又由它的子类去实现。AbstractRefreshableApplicationContext的子类AbstractXmlApplicationContext，AnnotationConfigWebApplicationContext，GroovyWebApplicationContext和XmlWebApplicationContext实现了该方法，而加载XML中BeanDefinition的是AbstractXmlApplicationContext和XmlWebApplicationContext子类。</p><p>　　　　AbstractXmlApplicationContext和XmlWebApplicationContext都是通过beanDefinitionReader去加载BeanDefinition，不同的是XmlWebApplicationContext只从configLocations中读取XML，而AbstractXmlApplicationContext还会尝试从configResources读取，其实最终都会通过Resource加载XML文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(DefaultListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// Create a new XmlBeanDefinitionReader for the given BeanFactory.</span></span><br><span class="line">XmlBeanDefinitionReader beanDefinitionReader = <span class="keyword">new</span> XmlBeanDefinitionReader(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Configure the bean definition reader with this context's</span></span><br><span class="line"><span class="comment">// resource loading environment.</span></span><br><span class="line">beanDefinitionReader.setEnvironment(getEnvironment());</span><br><span class="line">beanDefinitionReader.setResourceLoader(<span class="keyword">this</span>);</span><br><span class="line"><span class="comment">// EntityResolver用于获取XSD和DTD文件，来验证Element</span></span><br><span class="line">beanDefinitionReader.setEntityResolver(<span class="keyword">new</span> ResourceEntityResolver(<span class="keyword">this</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Allow a subclass to provide custom initialization of the reader,</span></span><br><span class="line"><span class="comment">// then proceed with actually loading the bean definitions.</span></span><br><span class="line">initBeanDefinitionReader(beanDefinitionReader);</span><br><span class="line">loadBeanDefinitions(beanDefinitionReader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AbstractXmlApplicationContext#loadBeanDefinitions(org.springframework.beans.factory.xml.XmlBeanDefinitionReader)</span><br><span class="line"> AbstractBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource...)</span><br><span class="line">  XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.Resource)</span><br><span class="line">   XmlBeanDefinitionReader#loadBeanDefinitions(org.springframework.core.io.support.EncodedResource)</span><br><span class="line">    XmlBeanDefinitionReader#doLoadBeanDefinitions(InputSource inputSource, Resource resource)</span><br><span class="line">     XmlBeanDefinitionReader#registerBeanDefinitions(Document doc, Resource resource)</span><br><span class="line">      DefaultBeanDefinitionDocumentReader#registerBeanDefinitions(Document doc, XmlReaderContext readerContext)</span><br><span class="line">       DefaultBeanDefinitionDocumentReader#doRegisterBeanDefinitions(Element root) </span><br><span class="line">        DefaultBeanDefinitionDocumentReader#parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate)</span><br></pre></td></tr></table></figure><p>　　　　在parseBeanDefinitions方法中就涉及到XML namespace处理器了,如果Element的namespaceUri为空或者为<a href="http://www.springframework.org/schema/beans" target="_blank" rel="noopener">http://www.springframework.org/schema/beans</a>则按照默认的NameSpace去处理Element，默认会处理的标签有beans、alias、bean和import；否则则会调用BeanDefinitionParserDelegate的parseCustomElement方法，尝试获取NamespaceHandler去解析XML Element。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">protected void parseBeanDefinitions(Element root, BeanDefinitionParserDelegate delegate) &#123;</span><br><span class="line">if (delegate.isDefaultNamespace(root)) &#123;</span><br><span class="line">NodeList nl = root.getChildNodes();</span><br><span class="line">for (int i = 0; i &lt; nl.getLength(); i++) &#123;</span><br><span class="line">Node node = nl.item(i);</span><br><span class="line">if (node instanceof Element) &#123;</span><br><span class="line">Element ele = (Element) node;</span><br><span class="line"></span><br><span class="line">if (delegate.isDefaultNamespace(ele)) &#123;</span><br><span class="line">parseDefaultElement(ele, delegate);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">delegate.parseCustomElement(ele);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">delegate.parseCustomElement(root);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanDefinitionParserDelegate的parseCustomElement方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BeanDefinition <span class="title">parseCustomElement</span><span class="params">(Element ele, @Nullable BeanDefinition containingBd)</span> </span>&#123;</span><br><span class="line">String namespaceUri = getNamespaceURI(ele);</span><br><span class="line"><span class="keyword">if</span> (namespaceUri == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">NamespaceHandler handler = <span class="keyword">this</span>.readerContext.getNamespaceHandlerResolver().resolve(namespaceUri);</span><br><span class="line"><span class="keyword">if</span> (handler == <span class="keyword">null</span>) &#123;</span><br><span class="line">error(<span class="string">"Unable to locate Spring NamespaceHandler for XML schema namespace ["</span> + namespaceUri + <span class="string">"]"</span>, ele);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> handler.parse(ele, <span class="keyword">new</span> ParserContext(<span class="keyword">this</span>.readerContext, <span class="keyword">this</span>, containingBd));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>　　　　自定义的NamespaceHandler是通过”META-INF/spring.handlers”文件注册的,如下图中的SofaBootNamespaceHandler。，用户通过继承NamespaceHandlerSupport类就能自定义NamespaceHandler。</p><img src="/2018/12/28/Spring-3-1-Loading-BeanDefinitions/NameSpaceHandler.png" title="SofaBootNamespaceHandler"><img src="/2018/12/28/Spring-3-1-Loading-BeanDefinitions/SofaBootNamespaceHandler.png" title="SofaBootNamespaceHandler"><p>　　　　在解析XML中的元素时涉及到XML元素验证，DTD验证文件由BeansDtdResolver加载，XSD文件由PluggableSchemaResolver加载，XSD验证文件是在”META-INF/spring.shemas”属性文件中声明的，key为systemId，value为文件路径。</p><h3 id="注解自动扫描"><a href="#注解自动扫描" class="headerlink" title="注解自动扫描"></a>注解自动扫描</h3><p>　　　　AnnotationConfigWebApplicationContext实现了AbstractRefreshableApplicationContext.loadBeanDefinitions的方法，在该方法中调用ClassPathBeanDefinitionScanne.scan扫描包。</p><p>　　　　ConfigurationClassPostProcessor实现了BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor接口，在postProcessBeanDefinitionRegistry和postProcessBeanFactory中会调用ConfigurationClassParser解析@Configuration注解标注的类，最终会通过ComponentScanAnnotationParser调用到ClassPathBeanDefinitionScanner的doScan。此外会调用 ConfigurationClassBeanDefinitionReader的loadBeanDefinitionsForConfigurationClass处理Configuration中BeanMethod等生成ConfigurationClassBeanDefinition。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassPathBeanDefinitionScanner#doScan(String... basePackages)</span><br><span class="line"> ClassPathScanningCandidateComponentProvider#findCandidateComponents(String basePackage)</span><br><span class="line">  <span class="comment">// 扫描@Component，并生成ScannedGenericBeanDefinition</span></span><br><span class="line">  ClassPathScanningCandidateComponentProvider#scanCandidateComponents</span><br></pre></td></tr></table></figure><h3 id="显式注册"><a href="#显式注册" class="headerlink" title="显式注册"></a>显式注册</h3><p>org.springframework.beans.factory.support.BeanDefinitionRegistry#registerBeanDefinition</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;BeanDefinition的自动加载&quot;&gt;&lt;a href=&quot;#BeanDefinition的自动加载&quot; class=&quot;headerlink&quot; title=&quot;BeanDefinition的自动加载&quot;&gt;&lt;/a&gt;BeanDefinition的自动加载&lt;/h2&gt;&lt;p&gt;　　
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-6-BeanFactoryPostProcessor</title>
    <link href="https://babyachievement.github.io/2018/12/27/Spring-6-BeanFactoryPostProcessor/"/>
    <id>https://babyachievement.github.io/2018/12/27/Spring-6-BeanFactoryPostProcessor/</id>
    <published>2018-12-27T07:45:51.000Z</published>
    <updated>2019-01-04T07:59:42.855Z</updated>
    
    <content type="html"><![CDATA[<p>BeanFactoryPostProcessor是一个扩展点接口，用来在BeanFactory创建完成，BeanDefinition加载完后修改Bean Definition中的属性。Application Context会自动探测到Bean Definitions中的BeanFactoryPostProcessor，并将它们在其他Bean创建前应用。这个接口对于使用自定义配置文件中的值覆盖应用上下文中配置的属性值，比如PropertyResourceConfigurer和它的子类就是用来实现这个目的的。BeanFactoryPostProcessor只可能会修改BeanDefinition，不会修Bean。如果修改Bean，会导致Bean过早实例化，侵犯容器，产生副作用。</p><p>BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor</p><a id="more"></a><p>一些常见的BeanFactoryPostProcessor：</p><ul><li>PropertyResourceConfigurer 加载配置中属性值</li><li>ConfigurationClassPostProcessor，使用CGLIB增强Configuration类，具体参考enhanceConfigurationClasses</li><li>CustomEditorConfigurer：注册PropertyEditor</li><li>Spring Boot中org.springframework.boot.context.config.ConfigFileApplicationListener.PropertySourceOrderingPostProcessor，用于对属性源进行排序，将默认的属性放到最后</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BeanFactoryPostProcessor是一个扩展点接口，用来在BeanFactory创建完成，BeanDefinition加载完后修改Bean Definition中的属性。Application Context会自动探测到Bean Definitions中的BeanFactoryPostProcessor，并将它们在其他Bean创建前应用。这个接口对于使用自定义配置文件中的值覆盖应用上下文中配置的属性值，比如PropertyResourceConfigurer和它的子类就是用来实现这个目的的。BeanFactoryPostProcessor只可能会修改BeanDefinition，不会修Bean。如果修改Bean，会导致Bean过早实例化，侵犯容器，产生副作用。&lt;/p&gt;
&lt;p&gt;BeanFactoryPostProcessor和BeanDefinitionRegistryPostProcessor&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-3-BeanDefinition</title>
    <link href="https://babyachievement.github.io/2018/12/27/Spring-3-BeanDefinition/"/>
    <id>https://babyachievement.github.io/2018/12/27/Spring-3-BeanDefinition/</id>
    <published>2018-12-27T02:07:52.000Z</published>
    <updated>2018-12-28T10:15:26.571Z</updated>
    
    <content type="html"><![CDATA[<h2 id="BeanDefinition是什么？"><a href="#BeanDefinition是什么？" class="headerlink" title="BeanDefinition是什么？"></a>BeanDefinition是什么？</h2><p>　　作为一个IOC容器框架，Spring管理Bean的生命周期，自然需要知道这些Bean用哪些类创建？在什么时候需要被创建？这些Bean在创建的时候需要哪些参数？创建后需要为其设置哪些属性？需要调用什么初始化方法？Bean的是什么类型的？Bean销毁时调用什么方法？</p><a id="more"></a><p>　　这些数据都是通过BeanDefinition描述的，在BeanDefinition中，使用beanClassName描述创建Bean的类，或者创建FactoryMethod，lazyInit判断Bean是在什么时候去创建，使用constructorArgumentValues描述创建时需要的参数，使用propertyValues描述创建Bean后要设置的属性，使用initMethodName描述初始化bean需要调用的方法，使用scope描述Bean的类型（singleton|prototype），使用destroyMethodName描述销毁Bean时要调用的方法。</p><p>　　除此之外，BeanDefinition还提供了primary属性，用于判断是不是首选；role用于区分Bean是ROLE_APPLICATION，ROLE_SUPPORT还是ROLE_INFRASTRUCTURE。</p><h2 id="BeanDefinition分类"><a href="#BeanDefinition分类" class="headerlink" title="BeanDefinition分类"></a>BeanDefinition分类</h2><img src="/2018/12/27/Spring-3-BeanDefinition/BeanDefinition.png" title="BeanDefinition类图"><p>　　BeanDefinition接口实现了AttributeAccessor和BeanMetadataElement接口，BeanMetadataElement接口具有访问source（配置源）的能力。AttributeAccessor接口提供了操作附加属性的能力。BeanDefinition有两个子类：AbstractBeanDefinition和AnnotatedBeanDefinition。</p><p>　　RootBeanDefinition,ChildBeanDefinition和GenericBeanDefinition都继承了AbstractBeanDefinition。</p><ol><li><p>GenericBeanDefinition是一站式的标准bean definition，除了具有指定类、可选的构造参数值和属性参数这些其它bean definition一样的特性外，它还具有通过parenetName属性来灵活设置parent bean definition。</p></li><li><p>RootBeanDefinition表示可合并的bean definition：即在spring beanFactory运行期间，支持一个特定的bean。RootBeanDefinition可以由多个彼此继承的BeanDefinition创建。RootBeanDefinition本质上是运行时统一的bean definition 视图。RootBeanDefinition也可以用来在配置阶段进行注册单个bean definition。但spring 2.5后，注册bean definition的首先方法是使用GenericBeanDefinition。GenericBeanDefinition支持动态定义父类依 赖，而非硬编码将其作为root bean definition。</p></li></ol><p>　　通常， GenericBeanDefinition用来注册用户可见的bean definition(可见的bean definition意味着可以在该类bean definition上定义post-processor来对bean进行操作)，此外可以使用parentName灵活地配置parent bean。RootBeanDefinition / ChildBeanDefinition用来定义已经预先确定了parent/child关系的bean definition。</p><p>　　AnnotatedBeanDefinition接口添加了获取注解元数据的方法getMetadata和getFactoryMethodMetadata。有三个子类ScannedGenericBeanDefinition，ConfigurationClassBeanDefinition和AnnotatedGenericBeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanDefinition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain the annotation metadata (as well as basic class metadata)</span></span><br><span class="line"><span class="comment"> * for this bean definition's bean class.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the annotation metadata object (never &#123;<span class="doctag">@code</span> null&#125;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Obtain metadata for this bean definition's factory method, if any.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the factory method metadata, or &#123;<span class="doctag">@code</span> null&#125; if none</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 4.1.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line"><span class="function">MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>ScannedGenericBeanDefinition类继承了GenericBeanDefinition类，并实现了AnnotatedBeanDefinition接口，这个类是基于ASM ClassReader获取注解信息的，ComponentScanAnnotationParser扫描类时将@Component或@Component为元注解的注解（如@Service、@Controller）的类解析成这个ScannedGenericBeanDefinition。 扫描过程具体参考：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.annotation.ComponentScanAnnotationParser#parse</span><br><span class="line">org.springframework.context.annotation.ClassPathBeanDefinitionScanner#scan</span><br><span class="line">org.springframework.context.annotation.ComponentScanBeanDefinitionParser#parse</span><br><span class="line"></span><br><span class="line"> -org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan</span><br><span class="line">  -org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents</span><br><span class="line">   -org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents</span><br></pre></td></tr></table></figure><ol start="2"><li><p>ConfigurationClassBeanDefinition，ConfigurationClassBeanDefinitionReader内部静态类，继承了RootBeanDefinition，并实现了AnnotatedBeanDefinition接口，Configuration Class内定义的Bean会被解析成ConfigurationClassBeanDefinition。</p></li><li><p>AnnotatedGenericBeanDefinition 主要用于测试希望在AnnotatedBeanDefinition上做操作的代码，比如Spring组件扫描支持中的策略实现。另外AnnotatedGenericBeanDefinition也用来描述@Configuration类。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitionForImportedConfigurationClass</span><span class="params">(ConfigurationClass configClass)</span> </span>&#123;</span><br><span class="line">AnnotationMetadata metadata = configClass.getMetadata();</span><br><span class="line">AnnotatedGenericBeanDefinition configBeanDef = <span class="keyword">new</span> AnnotatedGenericBeanDefinition(metadata);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>[1]. <a href="https://www.cnblogs.com/leihuazhe/p/9481124.html" target="_blank" rel="noopener">Spring-IOC RootBeanDefinition源码分析</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;BeanDefinition是什么？&quot;&gt;&lt;a href=&quot;#BeanDefinition是什么？&quot; class=&quot;headerlink&quot; title=&quot;BeanDefinition是什么？&quot;&gt;&lt;/a&gt;BeanDefinition是什么？&lt;/h2&gt;&lt;p&gt;　　作为一个IOC容器框架，Spring管理Bean的生命周期，自然需要知道这些Bean用哪些类创建？在什么时候需要被创建？这些Bean在创建的时候需要哪些参数？创建后需要为其设置哪些属性？需要调用什么初始化方法？Bean的是什么类型的？Bean销毁时调用什么方法？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-2-ApplicationContext</title>
    <link href="https://babyachievement.github.io/2018/12/26/Spring-2-ApplicationContext/"/>
    <id>https://babyachievement.github.io/2018/12/26/Spring-2-ApplicationContext/</id>
    <published>2018-12-26T02:28:56.000Z</published>
    <updated>2018-12-28T08:49:58.945Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h1><p>作为IOC的的核心组件之一，相比于BeanFactory，ApplicationContext还提供了ResourceLoader功能，ApplicationEventPublisher功能以及MessageSource功能。</p><h2 id="ResourceLoader"><a href="#ResourceLoader" class="headerlink" title="ResourceLoader"></a>ResourceLoader</h2><p>ResourceLoader接口用于加载各种路径下的资源，比如类路径下资源，文件系统中的资源等。ResourceLoader的默认实现DefaultResourceLoader，它的Resource getResource(String location) 方法会通过先注册的ProtocolResolver去尝试解析location，如果某个ProtocolResolver解析成功，直接返回一个Resource。如果解析失败，会依次判断是否以/开头，或者前缀为”classpath:”，如果都不满足则会创建以个URL，根据URL的协议读取本地文件或远程资源，具体代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource <span class="title">getResource</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">Assert.notNull(location, <span class="string">"Location must not be null"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ProtocolResolver protocolResolver : <span class="keyword">this</span>.protocolResolvers) &#123;</span><br><span class="line">Resource resource = protocolResolver.resolve(location, <span class="keyword">this</span>);</span><br><span class="line"><span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (location.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Try to parse the location as a URL...</span></span><br><span class="line">URL url = <span class="keyword">new</span> URL(location);</span><br><span class="line"><span class="keyword">return</span> (ResourceUtils.isFileURL(url) ? <span class="keyword">new</span> FileUrlResource(url) : <span class="keyword">new</span> UrlResource(url));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (MalformedURLException ex) &#123;</span><br><span class="line"><span class="comment">// No URL -&gt; resolve as resource path.</span></span><br><span class="line"><span class="keyword">return</span> getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="ApplicationEventPublisher"><a href="#ApplicationEventPublisher" class="headerlink" title="ApplicationEventPublisher"></a>ApplicationEventPublisher</h2><p>ApplicationEventPublisher接口用于发布ApplicationEvent事件。最终事件会通知到各个ApplicationListener。</p><img src="/2018/12/26/Spring-2-ApplicationContext/ApplicationEvent.png" title="ApplicationEvent类图"><h2 id="MessageSource"><a href="#MessageSource" class="headerlink" title="MessageSource"></a>MessageSource</h2><p>MessageSource主要用于解析消息，支持参数化和国际化。</p><h1 id="ApplicationContext-继承关系"><a href="#ApplicationContext-继承关系" class="headerlink" title="ApplicationContext 继承关系"></a>ApplicationContext 继承关系</h1><img src="/2018/12/26/Spring-2-ApplicationContext/ApplicationContext.png" title="ApplicationContext类图"><p>ApplicationContext接口有两个子接口分支：ConfigurableApplicationContext和WebApplicationContext。ConfigurableApplicationContext添加了配置功能，继承了Lifecycle和Closeable，提供了生命周期管理：addApplicationListener为ApplicationEventPublisher接口提供了ApplicationListener,addProtocolResolver方法提供了添加Resource解析器的功能，setEnvironment为EnvironmentCapable接口提供了修改Environment的功能，setId提供了修改ApplicationContext Id的功能，setParent为HierarchicalBeanFactory提供了设置父ApplicationContext和父BeanFactory的功能， 此外 ConfigurableApplicationContext还提供了refresh用于刷新，isActive判断状态，close方法用于关闭和释放资源，并且addBeanFactoryPostProcessor提供了添加BeanFactoryPostProcessor的功能，这些BeanFactoryPostProcessor将会在ApplicationContext内部的BeanFactory refresh时，评估任何BeanDefinition之前被调用。而WebApplicationContext提供了获取ServletContext方法，以及SCOPE_REQUEST、SCOPE_SESSION和SCOPE_APPLICATION Bean。</p><p>ConfigurableApplicationContext有一个继承接口ConfigurableWebApplicationContext和抽象子类AbstractApplicationContext。</p><p>AbstractApplicationContext类通过模板方法设计模式为子类提供了框架，具体的实现在子类中。其中最重要的是refresh方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line"><span class="comment">// 1. 为刷新context做准备，加载属性文件，设置环境信息和context状态信息</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Tell the subclass to refresh the internal bean factory.</span></span><br><span class="line"><span class="comment">// 2. 获取内部BeanFactory,其中调用了refreshBeanFactory和getBeanFactory，由子类实现</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 配置beanFactory的标准上下特征，比如ClassLoader和post-processors.</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 4. application context的内部bean Factory初始化完成后修改它，所有的bean definition都已经加载了，但还没有实例化，这个方法可以用来注册特殊的BeanPostProcessors</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Invoke factory processors registered as beans in the context.</span></span><br><span class="line"><span class="comment">// 5. 实例化所有的BeanFactoryPostProcessor bean，并按照指定的顺序调用，在singleton 实例化之前调用</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 注册拦截Bean创建的BeanPostProcessor</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7. 初始化Message资源</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8. 初始化事件广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9. 留给子类初始化其他特殊的Bean</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10. 在所有注册Bean中查找ApplicationListener Bean,并注册到消息广播器中</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11. 初始化剩下的单例Bean(非延迟加载的)</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12. 完成刷新过程,通知生命周期处理器lifecycleProcessor刷新过程,同时发出ContextRefreshEvent</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// Reset common introspection caches in Spring's core, since we</span></span><br><span class="line"><span class="comment">// might not ever need metadata for singleton beans anymore...</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>obtainFreshBeanFactory方法中调用了refreshBeanFactory和getBeanFactory方法，refreshBeanFactory和getBeanFactory方法都是模板方法，由子类去实现。AbstractApplicationContext的两个子类：GenericApplicationContext和AbstractRefreshableApplicationContext都提供了refreshBeanFactory的实现，GenericApplicationContext的实现只是设置refreshed和serializationId，AbstractRefreshableApplicationContext则会去创建DefaultListableBeanFactory，并调用loadBeanDefinitions加载BeanDefinition,loadBeanDefinitions方法也是一个抽象方法，具体实现由AbstractRefreshableApplicationContext子类实现。</p><p>ConfigurableWebApplicationContext是所有webContext的父接口，提供了提供了设置web信息的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServletContext</span><span class="params">(@Nullable ServletContext servletContext)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNamespace</span><span class="params">(@Nullable String namespace)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setConfigLocation</span><span class="params">(String configLocation)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setConfigLocations</span><span class="params">(String... configLocations)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ApplicationContext&quot;&gt;&lt;a href=&quot;#ApplicationContext&quot; class=&quot;headerlink&quot; title=&quot;ApplicationContext&quot;&gt;&lt;/a&gt;ApplicationContext&lt;/h1&gt;&lt;p&gt;作为IOC的
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-1-BeanPostProcessor</title>
    <link href="https://babyachievement.github.io/2018/12/25/Spring-5-BeanPostProcessor/"/>
    <id>https://babyachievement.github.io/2018/12/25/Spring-5-BeanPostProcessor/</id>
    <published>2018-12-25T02:06:28.000Z</published>
    <updated>2019-01-09T08:29:28.177Z</updated>
    
    <content type="html"><![CDATA[<p>BeanPostProcessor是Spring容器的一个扩展点，可以进行自定义的实例化、初始化、依赖装配、依赖检查等流程，即可以覆盖默认的实例化，也可以增强初始化、依赖注入、依赖检查等流程。BeanPostProcessor一共有两个回调方法postProcessBeforeInitialization和postProcessAfterInitialization，那这两个方法会在什么Spring执行流程中的哪个步骤执行呢？</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Creating instance of bean '"</span> + beanName + <span class="string">"'"</span>);</span><br><span class="line">&#125;</span><br><span class="line">RootBeanDefinition mbdToUse = mbd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make sure bean class is actually resolved at this point, and</span></span><br><span class="line"><span class="comment">// clone the bean definition in case of a dynamically resolved Class</span></span><br><span class="line"><span class="comment">// which cannot be stored in the shared merged bean definition.</span></span><br><span class="line">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);</span><br><span class="line"><span class="keyword">if</span> (resolvedClass != <span class="keyword">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="keyword">null</span>) &#123;</span><br><span class="line">mbdToUse = <span class="keyword">new</span> RootBeanDefinition(mbd);</span><br><span class="line">mbdToUse.setBeanClass(resolvedClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Prepare method overrides.</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">mbdToUse.prepareMethodOverrides();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanDefinitionValidationException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(mbdToUse.getResourceDescription(),</span><br><span class="line">beanName, <span class="string">"Validation of method overrides failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// Give BeanPostProcessors a chance to return a proxy instead of the target bean instance.</span></span><br><span class="line">Object bean = resolveBeforeInstantiation(beanName, mbdToUse);</span><br><span class="line"><span class="keyword">if</span> (bean != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(mbdToUse.getResourceDescription(), beanName,</span><br><span class="line"><span class="string">"BeanPostProcessor before instantiation of bean failed"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line"><span class="keyword">return</span> beanInstance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (BeanCreationException | ImplicitlyAppearedSingletonException ex) &#123;</span><br><span class="line"><span class="comment">// A previously detected exception with proper bean creation context already,</span></span><br><span class="line"><span class="comment">// or illegal singleton state to be communicated up to DefaultSingletonBeanRegistry.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationException(</span><br><span class="line">mbdToUse.getResourceDescription(), beanName, <span class="string">"Unexpected exception during bean creation"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BeanPostProcessor在Bean创建过程中的扩展点：</p><p>protected Object createBean(final String beanName, final RootBeanDefinition mbd, final Object[] args); 创建Bean</p><p>（1、resolveBeanClass(mbd, beanName); 解析Bean class，若class配置错误将抛出CannotLoadBeanClassException；</p><p>（2、mbd.prepareMethodOverrides(); 准备和验证配置的方法注入，若验证失败抛出BeanDefinitionValidationException</p><p>有关方法注入知识请参考【第三章】 DI 之 3.3 更多DI的知识 ——跟我学spring3 3.3.5 方法注入；</p><p>（3、Object bean = resolveBeforeInstantiation(beanName, mbd); 第一个BeanPostProcessor扩展点，此处只执行InstantiationAwareBeanPostProcessor类型的BeanPostProcessor Bean；</p><p>（3.1、bean = applyBeanPostProcessorsBeforeInstantiation(mbd.getBeanClass(), beanName);执行InstantiationAwareBeanPostProcessor的实例化的预处理回调方法postProcessBeforeInstantiation（自定义的实例化，如创建代理）；</p><p>（3.2、bean = applyBeanPostProcessorsAfterInitialization(bean, beanName);执行InstantiationAwareBeanPostProcessor的实例化的后处理回调方法postProcessAfterInitialization（如依赖注入），如果3.1处返回的Bean不为null才执行；</p><p>（4、如果3处的扩展点返回的bean不为空，直接返回该bean，后续流程不需要执行；</p><p>（5、Object beanInstance = doCreateBean(beanName, mbd, args); 执行spring的创建bean实例的流程；</p><p>（6、createBeanInstance(beanName, mbd, args); 实例化Bean</p><p>（6.1、instantiateUsingFactoryMethod 工厂方法实例化；请参考【<a href="http://jinnianshilongnian.iteye.com/blog/1413857】" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1413857】</a></p><p>（6.2、构造器实例化，请参考【<a href="http://jinnianshilongnian.iteye.com/blog/1413857】；" target="_blank" rel="noopener">http://jinnianshilongnian.iteye.com/blog/1413857】；</a></p><p>（6.2.1、如果之前已经解析过构造器</p><p>（6.2.1.1 autowireConstructor：有参调用autowireConstructor实例化</p><p>（6.2.1.2、instantiateBean：无参调用instantiateBean实例化；</p><p>（6.2.2、如果之前没有解析过构造器：</p><p>（6.2.2.1、通过SmartInstantiationAwareBeanPostProcessor的determineCandidateConstructors回调方法解析构造器，第二个BeanPostProcessor扩展点，返回第一个解析成功（返回值不为null）的构造器组，如AutowiredAnnotationBeanPostProcessor实现将自动扫描通过@Autowired/@Value注解的构造器从而可以完成构造器注入，请参考【第十二章】零配置 之 12.2 注解实现Bean依赖注入 ——跟我学spring3 ；</p><p>（6.2.2.2、autowireConstructor：如果（6.2.2.1返回的不为null，且是有参构造器，调用autowireConstructor实例化；</p><p>（6.2.2.3、instantiateBean： 否则调用无参构造器实例化；</p><p>（7、applyMergedBeanDefinitionPostProcessors(mbd, beanType,beanName);第三个BeanPostProcessor扩展点，执行Bean定义的合并；</p><p>（7.1、执行MergedBeanDefinitionPostProcessor的postProcessMergedBeanDefinition回调方法，进行bean定义的合并；</p><p>（8、addSingletonFactory(beanName, new ObjectFactory() {</p><pre><code>       public Object getObject() throws BeansException {              return getEarlyBeanReference(beanName, mbd, bean);       }});  及早暴露单例Bean引用，从而允许setter注入方式的循环引用</code></pre><p>（8.1、SmartInstantiationAwareBeanPostProcessor的getEarlyBeanReference；第四个BeanPostProcessor扩展点，当存在循环依赖时，通过该回调方法获取及早暴露的Bean实例；</p><p>（9、populateBean(beanName, mbd, instanceWrapper);装配Bean依赖</p><p>（9.1、InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation；第五个BeanPostProcessor扩展点，在实例化Bean之后，所有其他装配逻辑之前执行，如果false将阻止其他的InstantiationAwareBeanPostProcessor的postProcessAfterInstantiation的执行和从（9.2到（9.5的执行，通常返回true；</p><p>（9.2、autowireByName、autowireByType：根据名字和类型进行自动装配，自动装配的知识请参考【第三章】 DI 之 3.3 更多DI的知识 ——跟我学spring3  3.3.3  自动装配；</p><p>（9.3、InstantiationAwareBeanPostProcessor的postProcessPropertyValues：第六个BeanPostProcessor扩展点，完成其他定制的一些依赖注入，如AutowiredAnnotationBeanPostProcessor执行@Autowired注解注入，CommonAnnotationBeanPostProcessor执行@Resource等注解的注入，PersistenceAnnotationBeanPostProcessor执行@ PersistenceContext等JPA注解的注入，RequiredAnnotationBeanPostProcessor执行@ Required注解的检查等等，请参考【第十二章】零配置 之 12.2 注解实现Bean依赖注入 ——跟我学spring3；</p><p>（9.4、checkDependencies：依赖检查，请参考【第三章】 DI 之 3.3 更多DI的知识 ——跟我学spring3  3.3.4  依赖检查；</p><p>（9.5、applyPropertyValues：应用明确的setter属性注入，请参考【第三章】 DI 之 3.1 DI的配置使用 ——跟我学spring3 ；</p><p>（10、exposedObject = initializeBean(beanName, exposedObject, mbd); 执行初始化Bean流程；</p><p>（10.1、invokeAwareMethods（BeanNameAware、BeanClassLoaderAware、BeanFactoryAware）：调用一些Aware标识接口注入如BeanName、BeanFactory；</p><p>（10.2、BeanPostProcessor的postProcessBeforeInitialization：第七个扩展点，在调用初始化之前完成一些定制的初始化任务，如BeanValidationPostProcessor完成JSR-303 @Valid注解Bean验证，InitDestroyAnnotationBeanPostProcessor完成@PostConstruct注解的初始化方法调用，ApplicationContextAwareProcessor完成一些Aware接口的注入（如EnvironmentAware、ResourceLoaderAware、ApplicationContextAware），其返回值将替代原始的Bean对象；</p><p>（10.3、invokeInitMethods ： 调用初始化方法；</p><p>（10.3.1、InitializingBean的afterPropertiesSet ：调用InitializingBean的afterPropertiesSet回调方法；</p><p>（10.3.2、通过xml指定的自定义init-method ：调用通过xml配置的自定义init-method</p><p>（10.3.3、BeanPostProcessor的postProcessAfterInitialization ：第八个扩展点，AspectJAwareAdvisorAutoProxyCreator（完成xml风格的AOP配置(<a href="aop:config" target="_blank" rel="noopener">aop:config</a>)的目标对象包装到AOP代理对象）、AnnotationAwareAspectJAutoProxyCreator（完成@Aspectj注解风格（<a href="aop:aspectj-autoproxy" target="_blank" rel="noopener">aop:aspectj-autoproxy</a> @Aspect）的AOP配置的目标对象包装到AOP代理对象），其返回值将替代原始的Bean对象；</p><p>（11、if (earlySingletonExposure) {</p><pre><code>               Object earlySingletonReference = getSingleton(beanName, false);      ……} ：如果是earlySingleExposure，调用getSingle方法获取Bean实例；</code></pre><p>earlySingleExposure =(mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName))</p><p>只要单例Bean且允许循环引用（默认true）且当前单例Bean正在创建中</p><p>（11.1、如果是earlySingletonExposure调用getSingleton将触发【8】处ObjectFactory.getObject()的调用，通过【8.1】处的getEarlyBeanReference获取相关Bean（如包装目标对象的代理Bean）；（在循环引用Bean时可能引起Spring事务处理时自我调用的解决方案及一些实现方式的风险）；</p><p>（12、registerDisposableBeanIfNecessary(beanName, bean, mbd) ： 注册Bean的销毁方法（只有非原型Bean可注册）；</p><p>（12.1、单例Bean的销毁流程</p><p>（12.1.1、DestructionAwareBeanPostProcessor的postProcessBeforeDestruction ： 第九个扩展点，如InitDestroyAnnotationBeanPostProcessor完成@PreDestroy注解的销毁方法注册和调用；</p><p>（12.1.2、DisposableBean的destroy：注册/调用DisposableBean的destroy销毁方法；</p><p>（12.1.3、通过xml指定的自定义destroy-method ： 注册/调用通过XML指定的destroy-method销毁方法；</p><p>（12.1.2、Scope的registerDestructionCallback：注册自定义的Scope的销毁回调方法，如RequestScope、SessionScope等；其流程和【12.1 单例Bean的销毁流程一样】，关于自定义Scope请参考【第三章】 DI 之 3.4 Bean的作用域 ——跟我学spring3</p><p>（13、到此Bean实例化、依赖注入、初始化完毕可以返回创建好的bean了。</p><p>InstantiationAwareBeanPostProcessor</p><p>MergedBeanDefinitionPostProcessor </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;BeanPostProcessor是Spring容器的一个扩展点，可以进行自定义的实例化、初始化、依赖装配、依赖检查等流程，即可以覆盖默认的实例化，也可以增强初始化、依赖注入、依赖检查等流程。BeanPostProcessor一共有两个回调方法postProcessBeforeInitialization和postProcessAfterInitialization，那这两个方法会在什么Spring执行流程中的哪个步骤执行呢？&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Boot-0-注入方式</title>
    <link href="https://babyachievement.github.io/2018/12/24/Spring-Boot-0-%E6%B3%A8%E5%85%A5%E6%96%B9%E5%BC%8F/"/>
    <id>https://babyachievement.github.io/2018/12/24/Spring-Boot-0-注入方式/</id>
    <published>2018-12-24T08:23:01.000Z</published>
    <updated>2018-12-24T08:24:32.943Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1. 构造函数"></a>1. 构造函数</h2><h2 id="2-Setter"><a href="#2-Setter" class="headerlink" title="2. Setter"></a>2. Setter</h2><h2 id="3-强制赋值"><a href="#3-强制赋值" class="headerlink" title="3. 强制赋值"></a>3. 强制赋值</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1-构造函数&quot;&gt;&lt;a href=&quot;#1-构造函数&quot; class=&quot;headerlink&quot; title=&quot;1. 构造函数&quot;&gt;&lt;/a&gt;1. 构造函数&lt;/h2&gt;&lt;h2 id=&quot;2-Setter&quot;&gt;&lt;a href=&quot;#2-Setter&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="Spring" scheme="https://babyachievement.github.io/tags/Spring/"/>
    
      <category term="Spring Boot" scheme="https://babyachievement.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring-Boot-0-@Configuration</title>
    <link href="https://babyachievement.github.io/2018/12/21/Spring-Boot-0-Configuration/"/>
    <id>https://babyachievement.github.io/2018/12/21/Spring-Boot-0-Configuration/</id>
    <published>2018-12-21T07:33:34.000Z</published>
    <updated>2019-01-02T10:29:13.641Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-启动注册主程序类"><a href="#SpringBoot-启动注册主程序类" class="headerlink" title="SpringBoot 启动注册主程序类"></a>SpringBoot 启动注册主程序类</h1><p>org.springframework.context.support.GenericApplicationContext#registerBeanDefinition</p><p>org.springframework.boot.SpringApplication#run(java.lang.String…)<br>org.springframework.boot.SpringApplication#prepareContext(ConfigurableApplicationContext context,<br>            ConfigurableEnvironment environment, SpringApplicationRunListeners listeners,<br>            ApplicationArguments applicationArguments, Banner printedBanner)<br>org.springframework.boot.SpringApplication#load(ApplicationContext context, Object[] sources)<br>org.springframework.boot.BeanDefinitionLoader#load()<br>org.springframework.boot.BeanDefinitionLoader#load(java.lang.Object)<br>org.springframework.boot.BeanDefinitionLoader#load(java.lang.Class&lt;?&gt;)<br>org.springframework.context.annotation.AnnotatedBeanDefinitionReader#register(Class&lt;?&gt;… annotatedClasses)<br>org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(java.lang.Class&lt;?&gt;)<br>org.springframework.context.annotation.AnnotatedBeanDefinitionReader#register</p><p>将@SpringBootApplication注解类注册到BeanDefinition中，其他的类将由ConfigurationClassPostProcessor自动扫描。ConfigurationClassPostProcessor在processConfigBeanDefinitions中创建了ConfigurationClassParser，并调用ConfigurationClassParser.parse(candidates)方法解析@Configuration注解的类。整个调用流程如下：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BeanDefinitionRegistryPostProcessor扩展点</span></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor#postProcessBeanDefinitionRegistry</span><br><span class="line"><span class="comment">// 从BeanDefinitionRegistry找到所有的Full和Lite Configuration BeanDefinition</span></span><br><span class="line">org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions(BeanDefinitionRegistry registry)</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassParser#parse(java.util.Set&lt;org.springframework.beans.factory.config.BeanDefinitionHolder&gt;)</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassParser#parse(org.springframework.core.type.AnnotationMetadata, java.lang.String)</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass(ConfigurationClass configClass)</span><br><span class="line">org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass(ConfigurationClass configClass, SourceClass sourceClass)throws IOException</span><br><span class="line"><span class="comment">// 调用ComponentScanAnnotationParser解析@ComponentScan</span></span><br><span class="line">org.springframework.context.annotation.ComponentScanAnnotationParser#parseparse(AnnotationAttributes componentScan, final String declaringClass)</span><br><span class="line"><span class="comment">// 扫描包</span></span><br><span class="line">org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan</span><br></pre></td></tr></table></figure><h2 id="full-VS-lite-Configuration"><a href="#full-VS-lite-Configuration" class="headerlink" title="full VS lite Configuration"></a>full VS lite Configuration</h2><ol><li>如果类上使用了@Configuration，则为full Configuration<br>2.如果不满足1，检查类上是否使用了@Component、@ComponentScan、@Import或@ImportResource,如果都没有使用，则检查方法上是否使用了@Bean</li></ol><h2 id="Configuration解析过程"><a href="#Configuration解析过程" class="headerlink" title="@Configuration解析过程"></a>@Configuration解析过程</h2><p>ConfigurationClassPostProcessor同时实现了BeanDefinitionRegistryPostProcessor和</p><p>从已有的 BeanDefinition 中，找到配置类，然后解析出更多 BeanDefinition</p><p>postProcessBeanFactory<br>这里就是增强配置类，添加一个 ImportAwareBeanPostProcessor，这个类用来处理 ImportAware 接口实现</p><h2 id="Full-Configuration"><a href="#Full-Configuration" class="headerlink" title="Full Configuration"></a>Full Configuration</h2><p>Full Configuration 和</p><p>ConfigurationClassEnhancer</p><p>BeanMethodInterceptor</p><p>scope proxy</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot-启动注册主程序类&quot;&gt;&lt;a href=&quot;#SpringBoot-启动注册主程序类&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 启动注册主程序类&quot;&gt;&lt;/a&gt;SpringBoot 启动注册主程序类&lt;/h1&gt;&lt;p&gt;or
      
    
    </summary>
    
    
      <category term="Spring Boot" scheme="https://babyachievement.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot-1. 架构</title>
    <link href="https://babyachievement.github.io/2018/12/20/Spring-Boot-1-%E6%9E%B6%E6%9E%84/"/>
    <id>https://babyachievement.github.io/2018/12/20/Spring-Boot-1-架构/</id>
    <published>2018-12-20T02:30:01.000Z</published>
    <updated>2018-12-24T10:30:20.367Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ImportSelector"><a href="#ImportSelector" class="headerlink" title="ImportSelector"></a>ImportSelector</h2><p>Import</p><h2 id="autoconfigure模块"><a href="#autoconfigure模块" class="headerlink" title="autoconfigure模块"></a>autoconfigure模块</h2><p>@ConfigurationProperties和spring-configuration-metadata.json</p><p>spring-boot-autoconfigure-processor</p><p>ConditionalOnMissingBean<br>Conditional </p><h2 id="starter模块"><a href="#starter模块" class="headerlink" title="starter模块"></a>starter模块</h2><p>##Spring boot启动过程</p><p>org/springframework/boot/BeanDefinitionLoader.java:148</p><p>org.springframework.context.annotation.AnnotatedBeanDefinitionReader#register</p><p>org.springframework.context.annotation.AnnotatedBeanDefinitionReader#registerBean(java.lang.Class&lt;?&gt;)</p><p>org/springframework/context/annotation/ComponentScanAnnotationParser.java:123</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ImportSelector&quot;&gt;&lt;a href=&quot;#ImportSelector&quot; class=&quot;headerlink&quot; title=&quot;ImportSelector&quot;&gt;&lt;/a&gt;ImportSelector&lt;/h2&gt;&lt;p&gt;Import&lt;/p&gt;
&lt;h2 id=&quot;aut
      
    
    </summary>
    
    
      <category term="Spring Boot" scheme="https://babyachievement.github.io/tags/Spring-Boot/"/>
    
  </entry>
  
  <entry>
    <title>SOFA</title>
    <link href="https://babyachievement.github.io/2018/12/12/SOFA/"/>
    <id>https://babyachievement.github.io/2018/12/12/SOFA/</id>
    <published>2018-12-12T02:00:55.000Z</published>
    <updated>2018-12-12T02:18:09.683Z</updated>
    
    <content type="html"><![CDATA[<p>CQRS</p><p>扩展，扩展点， 业务身份识别</p><p>贫血模式</p><p>Repository Tunnel盒马概念</p><p>元数据引擎</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CQRS&lt;/p&gt;
&lt;p&gt;扩展，扩展点， 业务身份识别&lt;/p&gt;
&lt;p&gt;贫血模式&lt;/p&gt;
&lt;p&gt;Repository Tunnel盒马概念&lt;/p&gt;
&lt;p&gt;元数据引擎&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Spring-Security-Authentication</title>
    <link href="https://babyachievement.github.io/2018/11/28/Spring-Security-Authentication/"/>
    <id>https://babyachievement.github.io/2018/11/28/Spring-Security-Authentication/</id>
    <published>2018-11-28T02:36:50.000Z</published>
    <updated>2018-11-28T07:35:40.731Z</updated>
    
    <content type="html"><![CDATA[<p>org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter#configure(org.springframework.security.config.annotation.web.builders.HttpSecurity)</p><p>通过FormLoginConfigurer将UsernamePasswordAuthenticationFilter添加到HttpSecurity的filter中<br>通过ExpressionUrlAuthorizationConfigurer将FilterSecurityInterceptor添加到HttpSecurity的filter中</p><p>org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter#getHttp</p><p>将WebAsyncManagerIntegrationFilter，SecurityContextPersistenceFilter,HeaderWriterFilter,LogoutFilter,RequestCacheAwareFilter,SecurityContextHolderAwareRequestFilter,AnonymousAuthenticationFilter,SessionManagementFilter,ExceptionTranslationFilter天骄到HttpSecurity的filter列表中。</p><p>WebSecurityConfigurerAdapter的以下两个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">logger.debug(<span class="string">"Using default configure(HttpSecurity). If subclassed this will potentially override subclass configure(HttpSecurity)."</span>);</span><br><span class="line"></span><br><span class="line">http</span><br><span class="line">.authorizeRequests() <span class="comment">// 应用ExpressionUrlAuthorizationConfigurer</span></span><br><span class="line">.anyRequest().authenticated()</span><br><span class="line">.and()</span><br><span class="line">.formLogin().and() <span class="comment">// 应用FormLoginConfigurer</span></span><br><span class="line">.httpBasic();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> HttpSecurity <span class="title">getHttp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (http != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> http;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">DefaultAuthenticationEventPublisher eventPublisher = objectPostProcessor</span><br><span class="line">.postProcess(<span class="keyword">new</span> DefaultAuthenticationEventPublisher());</span><br><span class="line">localConfigureAuthenticationBldr.authenticationEventPublisher(eventPublisher);</span><br><span class="line"></span><br><span class="line">AuthenticationManager authenticationManager = authenticationManager();</span><br><span class="line">authenticationBuilder.parentAuthenticationManager(authenticationManager);</span><br><span class="line">authenticationBuilder.authenticationEventPublisher(eventPublisher);</span><br><span class="line">Map&lt;Class&lt;? extends Object&gt;, Object&gt; sharedObjects = createSharedObjects();</span><br><span class="line"></span><br><span class="line">http = <span class="keyword">new</span> HttpSecurity(objectPostProcessor, authenticationBuilder,</span><br><span class="line">sharedObjects);</span><br><span class="line"><span class="keyword">if</span> (!disableDefaults) &#123;</span><br><span class="line"><span class="comment">// @formatter:off</span></span><br><span class="line">http</span><br><span class="line">.csrf().and()</span><br><span class="line">.addFilter(<span class="keyword">new</span> WebAsyncManagerIntegrationFilter()) <span class="comment">//WebAsyncManagerIntegrationFilter</span></span><br><span class="line">.exceptionHandling().and()<span class="comment">// ExceptionTranslationFilter</span></span><br><span class="line">.headers().and()<span class="comment">// HeaderWriterFilter</span></span><br><span class="line">.sessionManagement().and()<span class="comment">// SessionManagementFilter</span></span><br><span class="line">.securityContext().and()<span class="comment">// SecurityContextPersistenceFilter</span></span><br><span class="line">.requestCache().and()<span class="comment">//RequestCacheAwareFilter</span></span><br><span class="line">.anonymous().and()<span class="comment">//AnonymousAuthenticationFilter</span></span><br><span class="line">.servletApi().and()<span class="comment">//SecurityContextHolderAwareRequestFilter</span></span><br><span class="line">.apply(<span class="keyword">new</span> DefaultLoginPageConfigurer&lt;&gt;()).and()<span class="comment">//DefaultLoginPageGeneratingFilter和DefaultLogoutPageGeneratingFilter</span></span><br><span class="line">.logout();<span class="comment">// LogoutFilter</span></span><br><span class="line"><span class="comment">// @formatter:on</span></span><br><span class="line">ClassLoader classLoader = <span class="keyword">this</span>.context.getClassLoader();</span><br><span class="line">List&lt;AbstractHttpConfigurer&gt; defaultHttpConfigurers =</span><br><span class="line">SpringFactoriesLoader.loadFactories(AbstractHttpConfigurer.class, classLoader);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (AbstractHttpConfigurer configurer : defaultHttpConfigurers) &#123;</span><br><span class="line">http.apply(configurer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">configure(http);</span><br><span class="line"><span class="keyword">return</span> http;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HttpSecurity最终会用上面的那些filter构建一个DefaultSecurityFilterChain，在构建DefaultSecurityFilterChain前，会使用FilterComparator对filter进行排序。<br>HttpSecurity会添加到WebSecurity的securityFilterChainBuilders中，被用来构建成一个FilterChainProxy，这个FilterChainiProxy在WebSecurityConfiguration中被注册到ApplicationContext中，名称为springSecurityFilterChain。</p><p>AbstractSecurityWebApplicationInitializer在onStartup时，调用insertSpringSecurityFilterChain，根据bean名称springSecurityFilterChain获取到，然后用其创建DelegatingFilterProxy，最终添加到ServletContext的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter#configure(org.springframework.security.conf
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://babyachievement.github.io/2018/11/27/Thymeleaf/"/>
    <id>https://babyachievement.github.io/2018/11/27/Thymeleaf/</id>
    <published>2018-11-27T06:58:54.261Z</published>
    <updated>2018-11-27T07:05:44.033Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: Thymeleaf<br>date: 2018-11-27 14:58:54</p><h2 id="tags-“Java”"><a href="#tags-“Java”" class="headerlink" title="tags: [“Java”]"></a>tags: [“Java”]</h2><h2 id="Thymeleaf标准表达式语法"><a href="#Thymeleaf标准表达式语法" class="headerlink" title="Thymeleaf标准表达式语法"></a>Thymeleaf标准表达式语法</h2><p>Thymeleaf有五种语法：</p><ul><li>${} :变量表达式</li><li>*{} :选择表达式</li><li>#{} :消息（i8n）表达式</li><li>@{} :链接表达式</li><li>~{} :片段表达式</li></ul><h3 id="变量表达式"><a href="#变量表达式" class="headerlink" title="变量表达式"></a>变量表达式</h3><p>变量表达式是OGNL表达式，或者Spring EL，在上下文变量中执行，也称作模型属性。写法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$&#123;session.user.name&#125;</span><br></pre></td></tr></table></figure></p><p>变量表达式可以作为标签属性：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">th:text</span>=<span class="string">"$&#123;book.author.name&#125;"</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>上面的写法等同于：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">((Book)context.getVariable(&quot;book&quot;)).getAuthor().getName()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: Thymeleaf&lt;br&gt;date: 2018-11-27 14:58:54&lt;/p&gt;
&lt;h2 id=&quot;tags-“Java”&quot;&gt;&lt;a href=&quot;#tags-“Java”&quot; class=&quot;headerlink&quot; title=&quot;tags: [“Java
      
    
    </summary>
    
    
  </entry>
  
</feed>
